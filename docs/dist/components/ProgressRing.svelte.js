/* src/components/ProgressRing.svelte generated by Svelte v3.34.0 */
import {
	SvelteComponent,
	append,
	attr,
	component_subscribe,
	detach,
	init,
	insert,
	noop,
	safe_not_equal,
	set_data,
	set_style,
	svg_element,
	text
} from "../../_snowpack/pkg/svelte/internal.js";

import { tweened } from "../../_snowpack/pkg/svelte/motion.js";
import { cubicOut } from "../../_snowpack/pkg/svelte/easing.js";

function create_fragment(ctx) {
	let svg;
	let circle;
	let circle_stroke_dasharray_value;
	let text_1;
	let t0_value = Math.round(/*$progressTweened*/ ctx[2]) + "";
	let t0;
	let t1;
	let svg_height_value;
	let svg_width_value;

	return {
		c() {
			svg = svg_element("svg");
			circle = svg_element("circle");
			text_1 = svg_element("text");
			t0 = text(t0_value);
			t1 = text("%");
			attr(circle, "fill", "transparent");
			attr(circle, "stroke-width", /*stroke*/ ctx[1]);
			attr(circle, "stroke-dasharray", circle_stroke_dasharray_value = /*circumference*/ ctx[5] + " " + /*circumference*/ ctx[5]);
			attr(circle, "stroke-dashoffset", /*strokeDashoffset*/ ctx[3]);
			attr(circle, "r", /*normalizedRadius*/ ctx[4]);
			attr(circle, "cx", /*radius*/ ctx[0]);
			attr(circle, "cy", /*radius*/ ctx[0]);
			attr(text_1, "x", "50%");
			attr(text_1, "y", "53%");
			attr(text_1, "text-anchor", "middle");
			attr(text_1, "class", "text-gray-800 fill-current");
			attr(text_1, "stroke-width", "1px");
			attr(text_1, "dy", ".2em");
			attr(svg, "height", svg_height_value = /*radius*/ ctx[0] * 2);
			attr(svg, "width", svg_width_value = /*radius*/ ctx[0] * 2);
			attr(svg, "class", "text-select stroke-current");
			set_style(svg, "filter", "brightness(" + (/*$progressTweened*/ ctx[2] / 100 / 2 + 0.5) + ") sepia(" + (0.5 - /*$progressTweened*/ ctx[2] / 100 / 2) + ") blur(" + (0.6 - /*$progressTweened*/ ctx[2] / 100 / 3) + "px)");
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			append(svg, circle);
			append(svg, text_1);
			append(text_1, t0);
			append(text_1, t1);
		},
		p(ctx, [dirty]) {
			if (dirty & /*stroke*/ 2) {
				attr(circle, "stroke-width", /*stroke*/ ctx[1]);
			}

			if (dirty & /*strokeDashoffset*/ 8) {
				attr(circle, "stroke-dashoffset", /*strokeDashoffset*/ ctx[3]);
			}

			if (dirty & /*radius*/ 1) {
				attr(circle, "cx", /*radius*/ ctx[0]);
			}

			if (dirty & /*radius*/ 1) {
				attr(circle, "cy", /*radius*/ ctx[0]);
			}

			if (dirty & /*$progressTweened*/ 4 && t0_value !== (t0_value = Math.round(/*$progressTweened*/ ctx[2]) + "")) set_data(t0, t0_value);

			if (dirty & /*radius*/ 1 && svg_height_value !== (svg_height_value = /*radius*/ ctx[0] * 2)) {
				attr(svg, "height", svg_height_value);
			}

			if (dirty & /*radius*/ 1 && svg_width_value !== (svg_width_value = /*radius*/ ctx[0] * 2)) {
				attr(svg, "width", svg_width_value);
			}

			if (dirty & /*$progressTweened*/ 4) {
				set_style(svg, "filter", "brightness(" + (/*$progressTweened*/ ctx[2] / 100 / 2 + 0.5) + ") sepia(" + (0.5 - /*$progressTweened*/ ctx[2] / 100 / 2) + ") blur(" + (0.6 - /*$progressTweened*/ ctx[2] / 100 / 3) + "px)");
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let strokeDashoffset;
	let $progressTweened;
	let { radius } = $$props;
	let { stroke } = $$props;
	let { progress } = $$props;
	const normalizedRadius = radius - stroke * 2;
	const circumference = normalizedRadius * 2 * Math.PI;
	const progressTweened = tweened(0, { duration: 400, easing: cubicOut });
	component_subscribe($$self, progressTweened, value => $$invalidate(2, $progressTweened = value));

	$$self.$$set = $$props => {
		if ("radius" in $$props) $$invalidate(0, radius = $$props.radius);
		if ("stroke" in $$props) $$invalidate(1, stroke = $$props.stroke);
		if ("progress" in $$props) $$invalidate(7, progress = $$props.progress);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*progress*/ 128) {
			$: progressTweened.set(progress);
		}

		if ($$self.$$.dirty & /*$progressTweened*/ 4) {
			$: $$invalidate(3, strokeDashoffset = circumference - $progressTweened / 100 * circumference);
		}
	};

	return [
		radius,
		stroke,
		$progressTweened,
		strokeDashoffset,
		normalizedRadius,
		circumference,
		progressTweened,
		progress
	];
}

class ProgressRing extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { radius: 0, stroke: 1, progress: 7 });
	}
}

export default ProgressRing;