import './ItemTable.svelte.css.proxy.js';
/* src/debug/ItemTable.svelte generated by Svelte v3.34.0 */
import {
	SvelteComponent,
	action_destroyer,
	add_render_callback,
	append,
	attr,
	check_outros,
	create_bidirectional_transition,
	create_component,
	create_in_transition,
	destroy_component,
	destroy_each,
	detach,
	element,
	empty,
	group_outros,
	init,
	insert,
	listen,
	mount_component,
	noop,
	outro_and_destroy_block,
	run_all,
	safe_not_equal,
	set_data,
	space,
	text,
	toggle_class,
	transition_in,
	transition_out,
	update_keyed_each
} from "../../_snowpack/pkg/svelte/internal.js";

import { scale, fade } from "../../_snowpack/pkg/svelte/transition.js";
import ColumnAnnotation from "../../core/debug/ColumnAnnotation.js";
import inView from "../actions/inView.js";
import { formatValue } from "./formatValues.js";
import ChangeSymbol from "./ChangeSymbol.svelte.js";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[13] = list[i];
	child_ctx[15] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[16] = list[i];
	child_ctx[18] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[19] = list[i];
	child_ctx[21] = i;
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[22] = list[i];
	return child_ctx;
}

function get_each_context_4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[22] = list[i];
	return child_ctx;
}

function get_each_context_5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[22] = list[i];
	return child_ctx;
}

// (57:8) {#each schema as column (column.name)}
function create_each_block_5(key_1, ctx) {
	let th;
	let t0_value = /*column*/ ctx[22].name + "";
	let t0;
	let t1;
	let th_class_value;
	let th_transition;
	let current;

	return {
		key: key_1,
		first: null,
		c() {
			th = element("th");
			t0 = text(t0_value);
			t1 = space();

			attr(th, "class", th_class_value = "bg-gray-300 shadow " + (/*column*/ ctx[22].annotation === ColumnAnnotation.ADDED
			? "text-green-800"
			: /*column*/ ctx[22].annotation === ColumnAnnotation.REMOVED
				? "text-red-800"
				: "") + " transition-colors duration-300 delay-200" + " svelte-5yqwk");

			this.first = th;
		},
		m(target, anchor) {
			insert(target, th, anchor);
			append(th, t0);
			append(th, t1);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty & /*schema*/ 1) && t0_value !== (t0_value = /*column*/ ctx[22].name + "")) set_data(t0, t0_value);

			if (!current || dirty & /*schema*/ 1 && th_class_value !== (th_class_value = "bg-gray-300 shadow " + (/*column*/ ctx[22].annotation === ColumnAnnotation.ADDED
			? "text-green-800"
			: /*column*/ ctx[22].annotation === ColumnAnnotation.REMOVED
				? "text-red-800"
				: "") + " transition-colors duration-300 delay-200" + " svelte-5yqwk")) {
				attr(th, "class", th_class_value);
			}
		},
		i(local) {
			if (current) return;

			add_render_callback(() => {
				if (!th_transition) th_transition = create_bidirectional_transition(th, scale, {}, true);
				th_transition.run(1);
			});

			current = true;
		},
		o(local) {
			if (!th_transition) th_transition = create_bidirectional_transition(th, scale, {}, false);
			th_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(th);
			if (detaching && th_transition) th_transition.end();
		}
	};
}

// (68:12) {#if pageIdx > 0}
function create_if_block_4(ctx) {
	let tr;

	return {
		c() {
			tr = element("tr");
			attr(tr, "class", "h-5");
		},
		m(target, anchor) {
			insert(target, tr, anchor);
		},
		d(detaching) {
			if (detaching) detach(tr);
		}
	};
}

// (86:20) {:else}
function create_else_block_1(ctx) {
	let td;

	return {
		c() {
			td = element("td");
			attr(td, "id", "page");
			attr(td, "class", "svelte-5yqwk");
		},
		m(target, anchor) {
			insert(target, td, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(td);
		}
	};
}

// (82:20) {#if itemIdx === 0}
function create_if_block_3(ctx) {
	let td;
	let div;
	let t0;
	let t1_value = /*page*/ ctx[13].index + "";
	let t1;
	let t2;

	let t3_value = (/*pageIsPinned*/ ctx[3]
	? ""
	: " / " + /*maxPage*/ ctx[2]) + "";

	let t3;

	return {
		c() {
			td = element("td");
			div = element("div");
			t0 = text("Page ");
			t1 = text(t1_value);
			t2 = space();
			t3 = text(t3_value);
			attr(td, "id", "page");
			attr(td, "class", "page bg-gray-50 align-top svelte-5yqwk");
		},
		m(target, anchor) {
			insert(target, td, anchor);
			append(td, div);
			append(div, t0);
			append(div, t1);
			append(div, t2);
			append(div, t3);
		},
		p(ctx, dirty) {
			if (dirty & /*renderedPages*/ 128 && t1_value !== (t1_value = /*page*/ ctx[13].index + "")) set_data(t1, t1_value);

			if (dirty & /*pageIsPinned, maxPage*/ 12 && t3_value !== (t3_value = (/*pageIsPinned*/ ctx[3]
			? ""
			: " / " + /*maxPage*/ ctx[2]) + "")) set_data(t3, t3_value);
		},
		d(detaching) {
			if (detaching) detach(td);
		}
	};
}

// (101:24) {#each schema as column}
function create_each_block_4(ctx) {
	let td;
	let t_value = formatValue(/*itemGroup*/ ctx[16].top.data[/*column*/ ctx[22].name]) + "";
	let t;

	return {
		c() {
			td = element("td");
			t = text(t_value);
			attr(td, "class", "select-all svelte-5yqwk");
		},
		m(target, anchor) {
			insert(target, td, anchor);
			append(td, t);
		},
		p(ctx, dirty) {
			if (dirty & /*renderedPages, schema*/ 129 && t_value !== (t_value = formatValue(/*itemGroup*/ ctx[16].top.data[/*column*/ ctx[22].name]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(td);
		}
	};
}

// (108:16) {#if expandedItemGroup && isExpanded(page.index, itemIdx)}
function create_if_block_2(ctx) {
	let each_1_anchor;
	let current;
	let each_value_2 = /*itemGroup*/ ctx[16].elements;
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*changes, renderedPages, schema, formatValue*/ 145) {
				each_value_2 = /*itemGroup*/ ctx[16].elements;
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_2.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (124:28) {#each schema as column}
function create_each_block_3(ctx) {
	let td;
	let t_value = formatValue(/*child*/ ctx[19].data[/*column*/ ctx[22].name]) + "";
	let t;

	return {
		c() {
			td = element("td");
			t = text(t_value);
			attr(td, "class", "select-all svelte-5yqwk");
		},
		m(target, anchor) {
			insert(target, td, anchor);
			append(td, t);
		},
		p(ctx, dirty) {
			if (dirty & /*renderedPages, schema*/ 129 && t_value !== (t_value = formatValue(/*child*/ ctx[19].data[/*column*/ ctx[22].name]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(td);
		}
	};
}

// (109:20) {#each itemGroup.elements as child, childIdx}
function create_each_block_2(ctx) {
	let tr;
	let td0;
	let t0;
	let td1;
	let changesymbol;
	let t1;
	let td2;
	let div1;
	let div0;
	let t2_value = "â”” " + /*childIdx*/ ctx[21] + "";
	let t2;
	let t3;
	let t4;
	let current;

	changesymbol = new ChangeSymbol({
			props: {
				changes: /*changes*/ ctx[4],
				item: /*child*/ ctx[19]
			}
		});

	let each_value_3 = /*schema*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	}

	return {
		c() {
			tr = element("tr");
			td0 = element("td");
			t0 = space();
			td1 = element("td");
			create_component(changesymbol.$$.fragment);
			t1 = space();
			td2 = element("td");
			div1 = element("div");
			div0 = element("div");
			t2 = text(t2_value);
			t3 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t4 = space();
			attr(td0, "id", "page");
			attr(td0, "class", "svelte-5yqwk");
			attr(td1, "class", "align-baseline svelte-5yqwk");
			attr(div0, "class", "w-8");
			attr(div1, "class", "flex space-x-1");
			attr(td2, "class", "whitespace-nowrap svelte-5yqwk");
			attr(tr, "class", "childs svelte-5yqwk");
			toggle_class(tr, "changePlus", /*changes*/ ctx[4].isPlusChange(/*child*/ ctx[19]));
			toggle_class(tr, "changeNeutral", /*changes*/ ctx[4].isNeutralChange(/*child*/ ctx[19]));
			toggle_class(tr, "changeMinus", /*changes*/ ctx[4].isMinusChange(/*child*/ ctx[19]));
		},
		m(target, anchor) {
			insert(target, tr, anchor);
			append(tr, td0);
			append(tr, t0);
			append(tr, td1);
			mount_component(changesymbol, td1, null);
			append(tr, t1);
			append(tr, td2);
			append(td2, div1);
			append(div1, div0);
			append(div0, t2);
			append(tr, t3);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr, null);
			}

			append(tr, t4);
			current = true;
		},
		p(ctx, dirty) {
			const changesymbol_changes = {};
			if (dirty & /*changes*/ 16) changesymbol_changes.changes = /*changes*/ ctx[4];
			if (dirty & /*renderedPages*/ 128) changesymbol_changes.item = /*child*/ ctx[19];
			changesymbol.$set(changesymbol_changes);

			if (dirty & /*formatValue, renderedPages, schema*/ 129) {
				each_value_3 = /*schema*/ ctx[0];
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3(ctx, each_value_3, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tr, t4);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_3.length;
			}

			if (dirty & /*changes, renderedPages*/ 144) {
				toggle_class(tr, "changePlus", /*changes*/ ctx[4].isPlusChange(/*child*/ ctx[19]));
			}

			if (dirty & /*changes, renderedPages*/ 144) {
				toggle_class(tr, "changeNeutral", /*changes*/ ctx[4].isNeutralChange(/*child*/ ctx[19]));
			}

			if (dirty & /*changes, renderedPages*/ 144) {
				toggle_class(tr, "changeMinus", /*changes*/ ctx[4].isMinusChange(/*child*/ ctx[19]));
			}
		},
		i(local) {
			if (current) return;
			transition_in(changesymbol.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(changesymbol.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(tr);
			destroy_component(changesymbol);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (73:12) {#each page.itemGroups as itemGroup, itemIdx}
function create_each_block_1(ctx) {
	let tr;
	let t0;
	let td0;
	let changesymbol;
	let t1;
	let span;
	let td1;
	let div1;
	let div0;
	let t2;
	let t3_value = (/*itemGroup*/ ctx[16].hasMany() ? "â€¦" : "") + "";
	let t3;
	let t4;
	let tr_intro;
	let t5;
	let show_if = /*expandedItemGroup*/ ctx[6] && /*isExpanded*/ ctx[9](/*page*/ ctx[13].index, /*itemIdx*/ ctx[18]);
	let if_block1_anchor;
	let current;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*itemIdx*/ ctx[18] === 0) return create_if_block_3;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block0 = current_block_type(ctx);

	changesymbol = new ChangeSymbol({
			props: {
				changes: /*changes*/ ctx[4],
				item: /*itemGroup*/ ctx[16].top
			}
		});

	let each_value_4 = /*schema*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value_4.length; i += 1) {
		each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
	}

	function click_handler() {
		return /*click_handler*/ ctx[11](/*itemGroup*/ ctx[16], /*page*/ ctx[13], /*itemIdx*/ ctx[18]);
	}

	let if_block1 = show_if && create_if_block_2(ctx);

	return {
		c() {
			tr = element("tr");
			if_block0.c();
			t0 = space();
			td0 = element("td");
			create_component(changesymbol.$$.fragment);
			t1 = space();
			span = element("span");
			td1 = element("td");
			div1 = element("div");
			div0 = element("div");
			t2 = text(/*itemIdx*/ ctx[18]);
			t3 = text(t3_value);
			t4 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t5 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			attr(td0, "class", "align-baseline svelte-5yqwk");
			attr(div1, "class", "flex space-x-0.5 items-center");
			attr(td1, "class", "align-top svelte-5yqwk");
			attr(span, "class", "contents");
			attr(tr, "class", "svelte-5yqwk");
			toggle_class(tr, "expandable", /*itemGroup*/ ctx[16].hasMany());
			toggle_class(tr, "expanded", /*expandedItemGroup*/ ctx[6] && /*isExpanded*/ ctx[9](/*page*/ ctx[13].index, /*itemIdx*/ ctx[18]));
			toggle_class(tr, "changePlus", /*changes*/ ctx[4].isPlusChange(/*itemGroup*/ ctx[16].top));
			toggle_class(tr, "changeNeutral", /*changes*/ ctx[4].isNeutralChange(/*itemGroup*/ ctx[16].top));
			toggle_class(tr, "changeMinus", /*changes*/ ctx[4].isMinusChange(/*itemGroup*/ ctx[16].top));
		},
		m(target, anchor) {
			insert(target, tr, anchor);
			if_block0.m(tr, null);
			append(tr, t0);
			append(tr, td0);
			mount_component(changesymbol, td0, null);
			append(tr, t1);
			append(tr, span);
			append(span, td1);
			append(td1, div1);
			append(div1, div0);
			append(div0, t2);
			append(div0, t3);
			append(span, t4);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(span, null);
			}

			insert(target, t5, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(span, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if_block0.p(ctx, dirty);
			const changesymbol_changes = {};
			if (dirty & /*changes*/ 16) changesymbol_changes.changes = /*changes*/ ctx[4];
			if (dirty & /*renderedPages*/ 128) changesymbol_changes.item = /*itemGroup*/ ctx[16].top;
			changesymbol.$set(changesymbol_changes);
			if ((!current || dirty & /*renderedPages*/ 128) && t3_value !== (t3_value = (/*itemGroup*/ ctx[16].hasMany() ? "â€¦" : "") + "")) set_data(t3, t3_value);

			if (dirty & /*formatValue, renderedPages, schema*/ 129) {
				each_value_4 = /*schema*/ ctx[0];
				let i;

				for (i = 0; i < each_value_4.length; i += 1) {
					const child_ctx = get_each_context_4(ctx, each_value_4, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_4(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(span, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_4.length;
			}

			if (dirty & /*renderedPages*/ 128) {
				toggle_class(tr, "expandable", /*itemGroup*/ ctx[16].hasMany());
			}

			if (dirty & /*expandedItemGroup, isExpanded, renderedPages*/ 704) {
				toggle_class(tr, "expanded", /*expandedItemGroup*/ ctx[6] && /*isExpanded*/ ctx[9](/*page*/ ctx[13].index, /*itemIdx*/ ctx[18]));
			}

			if (dirty & /*changes, renderedPages*/ 144) {
				toggle_class(tr, "changePlus", /*changes*/ ctx[4].isPlusChange(/*itemGroup*/ ctx[16].top));
			}

			if (dirty & /*changes, renderedPages*/ 144) {
				toggle_class(tr, "changeNeutral", /*changes*/ ctx[4].isNeutralChange(/*itemGroup*/ ctx[16].top));
			}

			if (dirty & /*changes, renderedPages*/ 144) {
				toggle_class(tr, "changeMinus", /*changes*/ ctx[4].isMinusChange(/*itemGroup*/ ctx[16].top));
			}

			if (dirty & /*expandedItemGroup, renderedPages*/ 192) show_if = /*expandedItemGroup*/ ctx[6] && /*isExpanded*/ ctx[9](/*page*/ ctx[13].index, /*itemIdx*/ ctx[18]);

			if (show_if) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*expandedItemGroup, renderedPages*/ 192) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(changesymbol.$$.fragment, local);

			if (!tr_intro) {
				add_render_callback(() => {
					tr_intro = create_in_transition(tr, fade, {});
					tr_intro.start();
				});
			}

			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(changesymbol.$$.fragment, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(tr);
			if_block0.d();
			destroy_component(changesymbol);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(t5);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
			mounted = false;
			dispose();
		}
	};
}

// (66:8) {#each renderedPages as page, pageIdx}
function create_each_block(ctx) {
	let t;
	let each_1_anchor;
	let current;
	let if_block = /*pageIdx*/ ctx[15] > 0 && create_if_block_4(ctx);
	let each_value_1 = /*page*/ ctx[13].itemGroups;
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			if (if_block) if_block.c();
			t = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*renderedPages, changes, schema, formatValue, expandedItemGroup, isExpanded, toggleRow, pageIsPinned, maxPage*/ 1757) {
				each_value_1 = /*page*/ ctx[13].itemGroups;
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (135:0) {#if !pageIsPinned}
function create_if_block(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*renderedMaxPage*/ ctx[5] < /*pages*/ ctx[1].length) return create_if_block_1;
		return create_else_block;
	}

	let current_block_type = select_block_type_1(ctx, -1);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (139:4) {:else}
function create_else_block(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			div.textContent = "FIN!";
			attr(div, "class", "my-6 text-center text-2xl");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (136:4) {#if renderedMaxPage < pages.length}
function create_if_block_1(ctx) {
	let span;
	let inView_action;
	let t0;
	let div;
	let mounted;
	let dispose;

	return {
		c() {
			span = element("span");
			t0 = space();
			div = element("div");
			div.textContent = "...";
			attr(div, "class", "my-6 text-center text-2xl");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			insert(target, t0, anchor);
			insert(target, div, anchor);

			if (!mounted) {
				dispose = [
					action_destroyer(inView_action = inView.call(null, span)),
					listen(span, "intersect", /*intersect_handler*/ ctx[12])
				];

				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
			if (detaching) detach(t0);
			if (detaching) detach(div);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment(ctx) {
	let table;
	let thead;
	let th0;
	let t0;
	let th1;
	let t1;
	let th2;
	let t3;
	let each_blocks_1 = [];
	let each0_lookup = new Map();
	let t4;
	let tbody;
	let t5;
	let if_block_anchor;
	let current;
	let each_value_5 = /*schema*/ ctx[0];
	const get_key = ctx => /*column*/ ctx[22].name;

	for (let i = 0; i < each_value_5.length; i += 1) {
		let child_ctx = get_each_context_5(ctx, each_value_5, i);
		let key = get_key(child_ctx);
		each0_lookup.set(key, each_blocks_1[i] = create_each_block_5(key, child_ctx));
	}

	let each_value = /*renderedPages*/ ctx[7];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	let if_block = !/*pageIsPinned*/ ctx[3] && create_if_block(ctx);

	return {
		c() {
			table = element("table");
			thead = element("thead");
			th0 = element("th");
			t0 = space();
			th1 = element("th");
			t1 = space();
			th2 = element("th");
			th2.textContent = "#";
			t3 = space();

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t4 = space();
			tbody = element("tbody");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t5 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			attr(th0, "class", "svelte-5yqwk");
			attr(th1, "class", "bg-gray-50 svelte-5yqwk");
			attr(th2, "class", "bg-gray-300 shadow svelte-5yqwk");
			attr(thead, "class", "");
			attr(table, "class", "w-full text-left");
		},
		m(target, anchor) {
			insert(target, table, anchor);
			append(table, thead);
			append(thead, th0);
			append(thead, t0);
			append(thead, th1);
			append(thead, t1);
			append(thead, th2);
			append(thead, t3);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(thead, null);
			}

			append(table, t4);
			append(table, tbody);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tbody, null);
			}

			insert(target, t5, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*schema, ColumnAnnotation*/ 1) {
				each_value_5 = /*schema*/ ctx[0];
				group_outros();
				each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx, each_value_5, each0_lookup, thead, outro_and_destroy_block, create_each_block_5, null, get_each_context_5);
				check_outros();
			}

			if (dirty & /*renderedPages, changes, schema, formatValue, expandedItemGroup, isExpanded, toggleRow, pageIsPinned, maxPage*/ 1757) {
				each_value = /*renderedPages*/ ctx[7];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(tbody, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (!/*pageIsPinned*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_5.length; i += 1) {
				transition_in(each_blocks_1[i]);
			}

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks_1.length; i += 1) {
				transition_out(each_blocks_1[i]);
			}

			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(table);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].d();
			}

			destroy_each(each_blocks, detaching);
			if (detaching) detach(t5);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

let maxItemsToRenderInOneLoad = 200;

function instance($$self, $$props, $$invalidate) {
	
	
	
	let { schema } = $$props;
	let { pages } = $$props;
	let { maxPage } = $$props;
	let { pageIsPinned } = $$props;
	let { changes } = $$props;
	let renderedMaxPage = 0;
	let expandedItemGroup;
	let renderedPages;

	function calculateNextPageToRenderTo() {
		if (renderedMaxPage >= maxPage) {
			return;
		}

		let itemCount = 0;

		for (let index = 0; index < pages.length; index++) {
			$$invalidate(5, renderedMaxPage++, renderedMaxPage);
			itemCount += pages[index].itemGroups.length;

			if (itemCount > maxItemsToRenderInOneLoad) {
				break;
			}
		}
	} // console.log(`Render pages 0 to ${renderedMaxPage} with ${itemCount} items`);

	const isExpanded = (pageIndex, itemIndex) => {
		return expandedItemGroup?.pageIndex === pageIndex && expandedItemGroup?.itemIndex === itemIndex;
	};

	const toggleRow = (pageIndex, itemIndex) => {
		$$invalidate(6, expandedItemGroup = isExpanded(pageIndex, itemIndex)
		? undefined
		: { pageIndex, itemIndex });
	};

	const click_handler = (itemGroup, page, itemIdx) => itemGroup.hasMany() && toggleRow(page.index, itemIdx);
	const intersect_handler = ({ detail }) => detail && calculateNextPageToRenderTo();

	$$self.$$set = $$props => {
		if ("schema" in $$props) $$invalidate(0, schema = $$props.schema);
		if ("pages" in $$props) $$invalidate(1, pages = $$props.pages);
		if ("maxPage" in $$props) $$invalidate(2, maxPage = $$props.maxPage);
		if ("pageIsPinned" in $$props) $$invalidate(3, pageIsPinned = $$props.pageIsPinned);
		if ("changes" in $$props) $$invalidate(4, changes = $$props.changes);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*pageIsPinned, pages, renderedMaxPage*/ 42) {
			$: {
				if (pageIsPinned) {
					$$invalidate(7, renderedPages = pages);
					$$invalidate(5, renderedMaxPage = 0);
				} else {
					calculateNextPageToRenderTo();
					$$invalidate(7, renderedPages = pages.slice(0, renderedMaxPage));
				}
			}
		}
	};

	return [
		schema,
		pages,
		maxPage,
		pageIsPinned,
		changes,
		renderedMaxPage,
		expandedItemGroup,
		renderedPages,
		calculateNextPageToRenderTo,
		isExpanded,
		toggleRow,
		click_handler,
		intersect_handler
	];
}

class ItemTable extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			schema: 0,
			pages: 1,
			maxPage: 2,
			pageIsPinned: 3,
			changes: 4
		});
	}
}

export default ItemTable;